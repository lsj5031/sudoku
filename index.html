<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Photo Sudoku Helper - Detailed Next Move</title>
<style>
  body { font-family: Arial, sans-serif; max-width: 900px; margin: 20px auto; text-align: center; }
  #uploadArea { border: 3px dashed #ccc; padding: 20px; margin: 20px; }
  #uploadedImage { max-width: 100%; margin: 20px 0; display: none; }
  table { margin: 20px auto; border-collapse: collapse; }
  td { width: 50px; height: 50px; text-align: center; font-size: 24px; border: 1px solid #999; position: relative; }
  .thick-right { border-right: 3px solid #000 !important; }
  .thick-bottom { border-bottom: 3px solid #000 !important; }
  input { width: 100%; height: 100%; text-align: center; font-size: 24px; border: none; background: transparent; }
  input:focus { background: #e0f7fa; outline: none; }
  input.solved { color: #1976d2; }
  input.hint { background: #ffeb3b; }
  input.related { background: #fff3cd; }
  input.incorrect { background: #ffcdd2; }
  input.locked { font-weight: bold; background: #f5f5f5; }
  button { padding: 10px 20px; margin: 5px; font-size: 16px; cursor: pointer; border-radius: 4px; border: 1px solid #999; }
  button:hover { background: #e0e0e0; }
  button.primary { background: #4caf50; color: white; border-color: #4caf50; }
  button.primary:hover { background: #388e3c; }
  #message { margin: 20px; padding: 15px; background: #f5f5f5; border-radius: 8px; font-size: 16px; min-height: 50px; text-align: left; max-width: 800px; margin-left: auto; margin-right: auto; border: 1px solid #ddd; }
  .bold { font-weight: bold; }
  .technique-name { color: #1976d2; font-weight: bold; }
  .hint-section { margin: 10px 0; padding: 10px; background: #e3f2fd; border-radius: 4px; }
  .button-group { margin: 10px 0; }
  #candidatesToggle { margin: 10px; }
  .candidates { position: absolute; top: 2px; left: 2px; right: 2px; bottom: 2px; display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr); font-size: 10px; color: #666; pointer-events: none; }
  .candidates span { display: flex; align-items: center; justify-content: center; }
  .candidates span.eliminated { color: #f44336; text-decoration: line-through; }
</style>
</head>
<body>

<h1>Sudoku Hint Helper</h1>
<p>Upload a photo for reference, enter numbers, and get detailed hints without spoiling the solution.</p>

<div id="uploadArea">
  <p>Drag & drop an image here or click to upload (for reference)</p>
  <input type="file" id="imageUpload" accept="image/*" style="display:none;">
</div>
<img id="uploadedImage" alt="Your uploaded Sudoku photo will appear here">

<table id="sudokuGrid"></table>

<div class="button-group">
  <button class="primary" onclick="getNextHint()">Get Next Hint</button>
  <button onclick="applyHint()">Apply Hint</button>
  <button onclick="showAllCandidates()">Show Candidates</button>
  <button onclick="clearHighlights()">Clear Highlights</button>
</div>
<div class="button-group">
  <button onclick="checkRules()">Check Rules</button>
  <button onclick="checkSolution()">Check Solution</button>
  <button onclick="lockPuzzle()">Lock Puzzle</button>
  <button onclick="clearGrid()">Clear Grid</button>
</div>
<div class="button-group">
  <button onclick="exportGrid()">Export Grid</button>
  <button onclick="document.getElementById('importFile').click()">Import Grid</button>
  <button onclick="shareViaURL()">Share via URL</button>
  <button onclick="loadFromURL()">Load from URL</button>
  <input type="file" id="importFile" accept=".txt,.sudoku,text/plain" style="display:none;">
</div>

<div id="message">Enter your Sudoku puzzle and click "Get Next Hint" to receive step-by-step guidance.</div>

<script>
let currentHint = null;
let showingCandidates = false;
let originalPuzzle = null;
let solverStartTime = 0;
const SOLVER_TIMEOUT = 5000; // 5 seconds

const table = document.getElementById("sudokuGrid");
for (let i = 0; i < 9; i++) {
  const row = table.insertRow();
  for (let j = 0; j < 9; j++) {
    const cell = row.insertCell();
    const input = document.createElement("input");
    input.type = "text";
    input.maxLength = 1;
    input.dataset.row = i;
    input.dataset.col = j;
    input.addEventListener("input", function() {
      this.value = this.value.replace(/[^1-9]/g, "");
      if (showingCandidates) showAllCandidates();
    });
    if (j % 3 === 2 && j !== 8) cell.classList.add("thick-right");
    if (i % 3 === 2 && i !== 8) cell.classList.add("thick-bottom");
    cell.appendChild(input);
  }
}

const uploadArea = document.getElementById("uploadArea");
const imageUpload = document.getElementById("imageUpload");
const uploadedImage = document.getElementById("uploadedImage");

uploadArea.addEventListener("click", () => imageUpload.click());
uploadArea.addEventListener("dragover", (e) => { e.preventDefault(); uploadArea.style.borderColor = "#000"; });
uploadArea.addEventListener("dragleave", () => { uploadArea.style.borderColor = "#ccc"; });
uploadArea.addEventListener("drop", (e) => {
  e.preventDefault();
  uploadArea.style.borderColor = "#ccc";
  if (e.dataTransfer.files.length) handleImage(e.dataTransfer.files[0]);
});

imageUpload.addEventListener("change", (e) => {
  if (e.target.files.length) handleImage(e.target.files[0]);
});

function handleImage(file) {
  // Validate file size (2MB limit)
  const MAX_SIZE = 2 * 1024 * 1024;
  if (file.size > MAX_SIZE) {
    showMessage("Image file too large. Maximum size is 2MB.", "error");
    return;
  }
  
  // Validate file type (exclude SVG)
  const allowedTypes = ["image/jpeg", "image/png", "image/gif", "image/webp"];
  if (!allowedTypes.includes(file.type)) {
    showMessage("Invalid image type. Please use JPEG, PNG, GIF, or WebP.", "error");
    return;
  }
  
  const reader = new FileReader();
  reader.onload = (e) => {
    uploadedImage.src = e.target.result;
    uploadedImage.style.display = "block";
  };
  reader.readAsDataURL(file);
}

function getGrid() {
  const grid = Array(9).fill().map(() => Array(9).fill(0));
  document.querySelectorAll("#sudokuGrid input").forEach(input => {
    const val = parseInt(input.value);
    if (val >= 1 && val <= 9) {
      grid[input.dataset.row][input.dataset.col] = val;
    }
  });
  return grid;
}

function setGrid(grid) {
  document.querySelectorAll("#sudokuGrid input").forEach(input => {
    const r = input.dataset.row;
    const c = input.dataset.col;
    const val = grid[r][c];
    input.value = val > 0 ? val : "";
    input.classList.remove("solved", "hint", "related");
  });
}

function getCandidates(grid, row, col) {
  if (grid[row][col] !== 0) return [];
  const candidates = [];
  for (let num = 1; num <= 9; num++) {
    if (isValidPlacement(grid, row, col, num)) candidates.push(num);
  }
  return candidates;
}

function getAllCandidates(grid) {
  const candidates = Array(9).fill().map(() => Array(9).fill().map(() => []));
  for (let r = 0; r < 9; r++) {
    for (let c = 0; c < 9; c++) {
      candidates[r][c] = getCandidates(grid, r, c);
    }
  }
  return candidates;
}

function isValidPlacement(grid, row, col, num) {
  for (let x = 0; x < 9; x++) if (grid[row][x] === num) return false;
  for (let x = 0; x < 9; x++) if (grid[x][col] === num) return false;
  const boxRow = Math.floor(row / 3) * 3;
  const boxCol = Math.floor(col / 3) * 3;
  for (let i = 0; i < 3; i++)
    for (let j = 0; j < 3; j++)
      if (grid[boxRow + i][boxCol + j] === num) return false;
  return true;
}

function getBoxName(row, col) {
  const boxRow = Math.floor(row / 3);
  const boxCol = Math.floor(col / 3);
  const boxNames = [
    ["top-left", "top-center", "top-right"],
    ["middle-left", "center", "middle-right"],
    ["bottom-left", "bottom-center", "bottom-right"]
  ];
  return boxNames[boxRow][boxCol];
}

function findNakedSingle(grid, candidates) {
  for (let row = 0; row < 9; row++) {
    for (let col = 0; col < 9; col++) {
      if (candidates[row][col].length === 1) {
        const num = candidates[row][col][0];
        const rowNums = [], colNums = [], boxNums = [];
        for (let c = 0; c < 9; c++) if (grid[row][c] > 0) rowNums.push(grid[row][c]);
        for (let r = 0; r < 9; r++) if (grid[r][col] > 0) colNums.push(grid[r][col]);
        const boxR = Math.floor(row / 3) * 3, boxC = Math.floor(col / 3) * 3;
        for (let i = 0; i < 3; i++)
          for (let j = 0; j < 3; j++)
            if (grid[boxR + i][boxC + j] > 0) boxNums.push(grid[boxR + i][boxC + j]);
        
        return {
          type: "naked_single",
          row, col, value: num,
          explanation: `<div class="hint-section">
            <span class="technique-name">Naked Single</span> at <strong>Row ${row + 1}, Column ${col + 1}</strong><br><br>
            This cell can only contain <strong>${num}</strong>.<br><br>
            <strong>Why?</strong><br>
            - Row ${row + 1} contains: ${rowNums.sort((a,b)=>a-b).join(", ") || "nothing yet"}<br>
            - Column ${col + 1} contains: ${colNums.sort((a,b)=>a-b).join(", ") || "nothing yet"}<br>
            - The ${getBoxName(row, col)} box contains: ${boxNums.sort((a,b)=>a-b).join(", ") || "nothing yet"}<br><br>
            Numbers 1-9 minus all those already used leaves only <strong>${num}</strong>.
          </div>`
        };
      }
    }
  }
  return null;
}

function findHiddenSingle(grid, candidates) {
  for (let row = 0; row < 9; row++) {
    for (let num = 1; num <= 9; num++) {
      const positions = [];
      for (let col = 0; col < 9; col++) {
        if (candidates[row][col].includes(num)) positions.push(col);
      }
      if (positions.length === 1) {
        const col = positions[0];
        const otherCandidates = candidates[row][col].filter(n => n !== num);
        return {
          type: "hidden_single",
          row, col, value: num,
          explanation: `<div class="hint-section">
            <span class="technique-name">Hidden Single</span> in Row ${row + 1}<br><br>
            Place <strong>${num}</strong> at <strong>Row ${row + 1}, Column ${col + 1}</strong><br><br>
            <strong>Why?</strong><br>
            Looking at Row ${row + 1}, the number <strong>${num}</strong> can only go in Column ${col + 1}.<br>
            All other cells in this row either already have numbers or cannot contain ${num}.<br><br>
            Even though this cell could also hold ${otherCandidates.length > 0 ? otherCandidates.join(" or ") : "other numbers"}, 
            it's the <em>only place</em> in Row ${row + 1} where ${num} can go.
          </div>`
        };
      }
    }
  }

  for (let col = 0; col < 9; col++) {
    for (let num = 1; num <= 9; num++) {
      const positions = [];
      for (let row = 0; row < 9; row++) {
        if (candidates[row][col].includes(num)) positions.push(row);
      }
      if (positions.length === 1) {
        const row = positions[0];
        const otherCandidates = candidates[row][col].filter(n => n !== num);
        return {
          type: "hidden_single",
          row, col, value: num,
          explanation: `<div class="hint-section">
            <span class="technique-name">Hidden Single</span> in Column ${col + 1}<br><br>
            Place <strong>${num}</strong> at <strong>Row ${row + 1}, Column ${col + 1}</strong><br><br>
            <strong>Why?</strong><br>
            Looking at Column ${col + 1}, the number <strong>${num}</strong> can only go in Row ${row + 1}.<br>
            All other cells in this column either already have numbers or cannot contain ${num}.<br><br>
            This cell has candidates {${candidates[row][col].join(", ")}}, but ${num} is "hidden" as the only option for this column.
          </div>`
        };
      }
    }
  }

  for (let boxRow = 0; boxRow < 3; boxRow++) {
    for (let boxCol = 0; boxCol < 3; boxCol++) {
      for (let num = 1; num <= 9; num++) {
        const positions = [];
        for (let i = 0; i < 3; i++) {
          for (let j = 0; j < 3; j++) {
            const r = boxRow * 3 + i;
            const c = boxCol * 3 + j;
            if (candidates[r][c].includes(num)) positions.push({row: r, col: c});
          }
        }
        if (positions.length === 1) {
          const {row, col} = positions[0];
          return {
            type: "hidden_single",
            row, col, value: num,
            explanation: `<div class="hint-section">
              <span class="technique-name">Hidden Single</span> in ${getBoxName(row, col)} box<br><br>
              Place <strong>${num}</strong> at <strong>Row ${row + 1}, Column ${col + 1}</strong><br><br>
              <strong>Why?</strong><br>
              Within the ${getBoxName(row, col)} 3x3 box, the number <strong>${num}</strong> can only go in this one cell.<br>
              All other empty cells in this box cannot contain ${num} due to row/column constraints.<br><br>
              This cell has candidates {${candidates[row][col].join(", ")}}, but ${num} is the only number that <em>must</em> go here.
            </div>`
          };
        }
      }
    }
  }
  return null;
}

function findNakedPair(grid, candidates) {
  for (let row = 0; row < 9; row++) {
    const pairs = [];
    for (let col = 0; col < 9; col++) {
      if (candidates[row][col].length === 2) {
        pairs.push({col, cands: candidates[row][col]});
      }
    }
    for (let i = 0; i < pairs.length; i++) {
      for (let j = i + 1; j < pairs.length; j++) {
        if (pairs[i].cands[0] === pairs[j].cands[0] && pairs[i].cands[1] === pairs[j].cands[1]) {
          const [n1, n2] = pairs[i].cands;
          const eliminations = [];
          for (let col = 0; col < 9; col++) {
            if (col !== pairs[i].col && col !== pairs[j].col) {
              if (candidates[row][col].includes(n1) || candidates[row][col].includes(n2)) {
                eliminations.push({row, col, nums: [n1, n2].filter(n => candidates[row][col].includes(n))});
              }
            }
          }
          if (eliminations.length > 0) {
            return {
              type: "naked_pair",
              cells: [{row, col: pairs[i].col}, {row, col: pairs[j].col}],
              values: [n1, n2],
              eliminations,
              explanation: `<div class="hint-section">
                <span class="technique-name">Naked Pair</span> in Row ${row + 1}<br><br>
                Cells at Columns ${pairs[i].col + 1} and ${pairs[j].col + 1} both contain only candidates {${n1}, ${n2}}.<br><br>
                <strong>What this means:</strong><br>
                These two numbers MUST go in these two cells (we don't know which goes where yet).<br>
                Therefore, ${n1} and ${n2} can be <em>eliminated</em> from all other cells in Row ${row + 1}.<br><br>
                <strong>Eliminations:</strong><br>
                ${eliminations.map(e => `- Remove ${e.nums.join(", ")} from Row ${e.row + 1}, Column ${e.col + 1}`).join("<br>")}
              </div>`
            };
          }
        }
      }
    }
  }

  for (let col = 0; col < 9; col++) {
    const pairs = [];
    for (let row = 0; row < 9; row++) {
      if (candidates[row][col].length === 2) {
        pairs.push({row, cands: candidates[row][col]});
      }
    }
    for (let i = 0; i < pairs.length; i++) {
      for (let j = i + 1; j < pairs.length; j++) {
        if (pairs[i].cands[0] === pairs[j].cands[0] && pairs[i].cands[1] === pairs[j].cands[1]) {
          const [n1, n2] = pairs[i].cands;
          const eliminations = [];
          for (let row = 0; row < 9; row++) {
            if (row !== pairs[i].row && row !== pairs[j].row) {
              if (candidates[row][col].includes(n1) || candidates[row][col].includes(n2)) {
                eliminations.push({row, col, nums: [n1, n2].filter(n => candidates[row][col].includes(n))});
              }
            }
          }
          if (eliminations.length > 0) {
            return {
              type: "naked_pair",
              cells: [{row: pairs[i].row, col}, {row: pairs[j].row, col}],
              values: [n1, n2],
              eliminations,
              explanation: `<div class="hint-section">
                <span class="technique-name">Naked Pair</span> in Column ${col + 1}<br><br>
                Cells at Rows ${pairs[i].row + 1} and ${pairs[j].row + 1} both contain only candidates {${n1}, ${n2}}.<br><br>
                <strong>What this means:</strong><br>
                These two numbers MUST go in these two cells.<br>
                Therefore, ${n1} and ${n2} can be <em>eliminated</em> from all other cells in Column ${col + 1}.<br><br>
                <strong>Eliminations:</strong><br>
                ${eliminations.map(e => `- Remove ${e.nums.join(", ")} from Row ${e.row + 1}, Column ${e.col + 1}`).join("<br>")}
              </div>`
            };
          }
        }
      }
    }
  }
  return null;
}

function findPointingPair(grid, candidates) {
  for (let boxRow = 0; boxRow < 3; boxRow++) {
    for (let boxCol = 0; boxCol < 3; boxCol++) {
      for (let num = 1; num <= 9; num++) {
        const positions = [];
        for (let i = 0; i < 3; i++) {
          for (let j = 0; j < 3; j++) {
            const r = boxRow * 3 + i;
            const c = boxCol * 3 + j;
            if (candidates[r][c].includes(num)) {
              positions.push({row: r, col: c});
            }
          }
        }
        
        if (positions.length >= 2 && positions.length <= 3) {
          const allSameRow = positions.every(p => p.row === positions[0].row);
          const allSameCol = positions.every(p => p.col === positions[0].col);
          
          if (allSameRow) {
            const row = positions[0].row;
            const eliminations = [];
            for (let col = 0; col < 9; col++) {
              const inBox = col >= boxCol * 3 && col < boxCol * 3 + 3;
              if (!inBox && candidates[row][col].includes(num)) {
                eliminations.push({row, col});
              }
            }
            if (eliminations.length > 0) {
              return {
                type: "pointing_pair",
                positions,
                value: num,
                eliminations,
                explanation: `<div class="hint-section">
                  <span class="technique-name">Pointing Pair/Triple</span><br><br>
                  In the ${getBoxName(positions[0].row, positions[0].col)} box, the number <strong>${num}</strong> can only appear in Row ${row + 1}.<br><br>
                  <strong>What this means:</strong><br>
                  Since ${num} must be somewhere in Row ${row + 1} within this box, it CANNOT appear elsewhere in Row ${row + 1}.<br><br>
                  <strong>Eliminations:</strong><br>
                  ${eliminations.map(e => `- Remove ${num} from Row ${e.row + 1}, Column ${e.col + 1}`).join("<br>")}
                </div>`
              };
            }
          }
          
          if (allSameCol) {
            const col = positions[0].col;
            const eliminations = [];
            for (let row = 0; row < 9; row++) {
              const inBox = row >= boxRow * 3 && row < boxRow * 3 + 3;
              if (!inBox && candidates[row][col].includes(num)) {
                eliminations.push({row, col});
              }
            }
            if (eliminations.length > 0) {
              return {
                type: "pointing_pair",
                positions,
                value: num,
                eliminations,
                explanation: `<div class="hint-section">
                  <span class="technique-name">Pointing Pair/Triple</span><br><br>
                  In the ${getBoxName(positions[0].row, positions[0].col)} box, the number <strong>${num}</strong> can only appear in Column ${col + 1}.<br><br>
                  <strong>What this means:</strong><br>
                  Since ${num} must be somewhere in Column ${col + 1} within this box, it CANNOT appear elsewhere in Column ${col + 1}.<br><br>
                  <strong>Eliminations:</strong><br>
                  ${eliminations.map(e => `- Remove ${num} from Row ${e.row + 1}, Column ${e.col + 1}`).join("<br>")}
                </div>`
              };
            }
          }
        }
      }
    }
  }
  return null;
}

function findBoxLineReduction(grid, candidates) {
  for (let row = 0; row < 9; row++) {
    for (let num = 1; num <= 9; num++) {
      const positions = [];
      for (let col = 0; col < 9; col++) {
        if (candidates[row][col].includes(num)) {
          positions.push({row, col});
        }
      }
      if (positions.length >= 2 && positions.length <= 3) {
        const boxCol = Math.floor(positions[0].col / 3);
        const allSameBox = positions.every(p => Math.floor(p.col / 3) === boxCol);
        if (allSameBox) {
          const boxRow = Math.floor(row / 3);
          const eliminations = [];
          for (let i = 0; i < 3; i++) {
            for (let j = 0; j < 3; j++) {
              const r = boxRow * 3 + i;
              const c = boxCol * 3 + j;
              if (r !== row && candidates[r][c].includes(num)) {
                eliminations.push({row: r, col: c});
              }
            }
          }
          if (eliminations.length > 0) {
            return {
              type: "box_line",
              positions,
              value: num,
              eliminations,
              explanation: `<div class="hint-section">
                <span class="technique-name">Box-Line Reduction</span><br><br>
                In Row ${row + 1}, the number <strong>${num}</strong> can only appear within the ${getBoxName(row, positions[0].col)} box.<br><br>
                <strong>What this means:</strong><br>
                Since ${num} in Row ${row + 1} is confined to this box, it can be eliminated from other rows within the same box.<br><br>
                <strong>Eliminations:</strong><br>
                ${eliminations.map(e => `- Remove ${num} from Row ${e.row + 1}, Column ${e.col + 1}`).join("<br>")}
              </div>`
            };
          }
        }
      }
    }
  }

  for (let col = 0; col < 9; col++) {
    for (let num = 1; num <= 9; num++) {
      const positions = [];
      for (let row = 0; row < 9; row++) {
        if (candidates[row][col].includes(num)) {
          positions.push({row, col});
        }
      }
      if (positions.length >= 2 && positions.length <= 3) {
        const boxRow = Math.floor(positions[0].row / 3);
        const allSameBox = positions.every(p => Math.floor(p.row / 3) === boxRow);
        if (allSameBox) {
          const boxCol = Math.floor(col / 3);
          const eliminations = [];
          for (let i = 0; i < 3; i++) {
            for (let j = 0; j < 3; j++) {
              const r = boxRow * 3 + i;
              const c = boxCol * 3 + j;
              if (c !== col && candidates[r][c].includes(num)) {
                eliminations.push({row: r, col: c});
              }
            }
          }
          if (eliminations.length > 0) {
            return {
              type: "box_line",
              positions,
              value: num,
              eliminations,
              explanation: `<div class="hint-section">
                <span class="technique-name">Box-Line Reduction</span><br><br>
                In Column ${col + 1}, the number <strong>${num}</strong> can only appear within the ${getBoxName(positions[0].row, col)} box.<br><br>
                <strong>What this means:</strong><br>
                Since ${num} in Column ${col + 1} is confined to this box, it can be eliminated from other columns within the same box.<br><br>
                <strong>Eliminations:</strong><br>
                ${eliminations.map(e => `- Remove ${num} from Row ${e.row + 1}, Column ${e.col + 1}`).join("<br>")}
              </div>`
            };
          }
        }
      }
    }
  }
  return null;
}

function findXWing(grid, candidates) {
  for (let num = 1; num <= 9; num++) {
    const rowPositions = [];
    for (let row = 0; row < 9; row++) {
      const cols = [];
      for (let col = 0; col < 9; col++) {
        if (candidates[row][col].includes(num)) cols.push(col);
      }
      if (cols.length === 2) {
        rowPositions.push({row, cols});
      }
    }
    
    for (let i = 0; i < rowPositions.length; i++) {
      for (let j = i + 1; j < rowPositions.length; j++) {
        if (rowPositions[i].cols[0] === rowPositions[j].cols[0] && 
            rowPositions[i].cols[1] === rowPositions[j].cols[1]) {
          const row1 = rowPositions[i].row;
          const row2 = rowPositions[j].row;
          const col1 = rowPositions[i].cols[0];
          const col2 = rowPositions[i].cols[1];
          
          const eliminations = [];
          for (let row = 0; row < 9; row++) {
            if (row !== row1 && row !== row2) {
              if (candidates[row][col1].includes(num)) {
                eliminations.push({row, col: col1});
              }
              if (candidates[row][col2].includes(num)) {
                eliminations.push({row, col: col2});
              }
            }
          }
          
          if (eliminations.length > 0) {
            return {
              type: "x_wing",
              positions: [
                {row: row1, col: col1}, {row: row1, col: col2},
                {row: row2, col: col1}, {row: row2, col: col2}
              ],
              value: num,
              eliminations,
              explanation: `<div class="hint-section">
                <span class="technique-name">X-Wing</span> for number ${num}<br><br>
                In Rows ${row1 + 1} and ${row2 + 1}, the number <strong>${num}</strong> can only appear in Columns ${col1 + 1} and ${col2 + 1}.<br><br>
                <strong>What this means:</strong><br>
                These four cells form an "X" pattern. The number ${num} must go in two of these cells diagonally.<br>
                Either (R${row1 + 1}C${col1 + 1} and R${row2 + 1}C${col2 + 1}) OR (R${row1 + 1}C${col2 + 1} and R${row2 + 1}C${col1 + 1}).<br><br>
                Therefore, ${num} can be <em>eliminated</em> from all other cells in Columns ${col1 + 1} and ${col2 + 1}.<br><br>
                <strong>Eliminations:</strong><br>
                ${eliminations.map(e => `- Remove ${num} from Row ${e.row + 1}, Column ${e.col + 1}`).join("<br>")}
              </div>`
            };
          }
        }
      }
    }
    
    const colPositions = [];
    for (let col = 0; col < 9; col++) {
      const rows = [];
      for (let row = 0; row < 9; row++) {
        if (candidates[row][col].includes(num)) rows.push(row);
      }
      if (rows.length === 2) {
        colPositions.push({col, rows});
      }
    }
    
    for (let i = 0; i < colPositions.length; i++) {
      for (let j = i + 1; j < colPositions.length; j++) {
        if (colPositions[i].rows[0] === colPositions[j].rows[0] && 
            colPositions[i].rows[1] === colPositions[j].rows[1]) {
          const col1 = colPositions[i].col;
          const col2 = colPositions[j].col;
          const row1 = colPositions[i].rows[0];
          const row2 = colPositions[i].rows[1];
          
          const eliminations = [];
          for (let col = 0; col < 9; col++) {
            if (col !== col1 && col !== col2) {
              if (candidates[row1][col].includes(num)) {
                eliminations.push({row: row1, col});
              }
              if (candidates[row2][col].includes(num)) {
                eliminations.push({row: row2, col});
              }
            }
          }
          
          if (eliminations.length > 0) {
            return {
              type: "x_wing",
              positions: [
                {row: row1, col: col1}, {row: row1, col: col2},
                {row: row2, col: col1}, {row: row2, col: col2}
              ],
              value: num,
              eliminations,
              explanation: `<div class="hint-section">
                <span class="technique-name">X-Wing</span> for number ${num}<br><br>
                In Columns ${col1 + 1} and ${col2 + 1}, the number <strong>${num}</strong> can only appear in Rows ${row1 + 1} and ${row2 + 1}.<br><br>
                <strong>What this means:</strong><br>
                These four cells form an "X" pattern. The number ${num} must go in two of these cells diagonally.<br>
                Either (R${row1 + 1}C${col1 + 1} and R${row2 + 1}C${col2 + 1}) OR (R${row1 + 1}C${col2 + 1} and R${row2 + 1}C${col1 + 1}).<br><br>
                Therefore, ${num} can be <em>eliminated</em> from all other cells in Rows ${row1 + 1} and ${row2 + 1}.<br><br>
                <strong>Eliminations:</strong><br>
                ${eliminations.map(e => `- Remove ${num} from Row ${e.row + 1}, Column ${e.col + 1}`).join("<br>")}
              </div>`
            };
          }
        }
      }
    }
  }
  return null;
}

function findSwordfish(grid, candidates) {
  for (let num = 1; num <= 9; num++) {
    const rowData = [];
    for (let row = 0; row < 9; row++) {
      const cols = [];
      for (let col = 0; col < 9; col++) {
        if (candidates[row][col].includes(num)) cols.push(col);
      }
      if (cols.length >= 2 && cols.length <= 3) {
        rowData.push({row, cols});
      }
    }
    
    for (let i = 0; i < rowData.length; i++) {
      for (let j = i + 1; j < rowData.length; j++) {
        for (let k = j + 1; k < rowData.length; k++) {
          const allCols = new Set([...rowData[i].cols, ...rowData[j].cols, ...rowData[k].cols]);
          if (allCols.size === 3) {
            const cols = Array.from(allCols).sort((a, b) => a - b);
            const rows = [rowData[i].row, rowData[j].row, rowData[k].row];
            
            const eliminations = [];
            for (let row = 0; row < 9; row++) {
              if (!rows.includes(row)) {
                for (const col of cols) {
                  if (candidates[row][col].includes(num)) {
                    eliminations.push({row, col});
                  }
                }
              }
            }
            
            if (eliminations.length > 0) {
              const positions = [];
              for (const row of rows) {
                for (const col of cols) {
                  if (candidates[row][col].includes(num)) {
                    positions.push({row, col});
                  }
                }
              }
              
              return {
                type: "swordfish",
                positions,
                value: num,
                eliminations,
                explanation: `<div class="hint-section">
                  <span class="technique-name">Swordfish</span> for number ${num}<br><br>
                  In Rows ${rows.map(r => r + 1).join(", ")}, the number <strong>${num}</strong> is confined to Columns ${cols.map(c => c + 1).join(", ")}.<br><br>
                  <strong>What this means:</strong><br>
                  This forms a Swordfish pattern - ${num} must appear exactly once in each of these 3 rows,<br>
                  and all possible positions are within these 3 columns.<br><br>
                  Therefore, ${num} can be <em>eliminated</em> from all other cells in Columns ${cols.map(c => c + 1).join(", ")}.<br><br>
                  <strong>Eliminations:</strong><br>
                  ${eliminations.map(e => `- Remove ${num} from Row ${e.row + 1}, Column ${e.col + 1}`).join("<br>")}
                </div>`
              };
            }
          }
        }
      }
    }
    
    const colData = [];
    for (let col = 0; col < 9; col++) {
      const rows = [];
      for (let row = 0; row < 9; row++) {
        if (candidates[row][col].includes(num)) rows.push(row);
      }
      if (rows.length >= 2 && rows.length <= 3) {
        colData.push({col, rows});
      }
    }
    
    for (let i = 0; i < colData.length; i++) {
      for (let j = i + 1; j < colData.length; j++) {
        for (let k = j + 1; k < colData.length; k++) {
          const allRows = new Set([...colData[i].rows, ...colData[j].rows, ...colData[k].rows]);
          if (allRows.size === 3) {
            const rows = Array.from(allRows).sort((a, b) => a - b);
            const cols = [colData[i].col, colData[j].col, colData[k].col];
            
            const eliminations = [];
            for (let col = 0; col < 9; col++) {
              if (!cols.includes(col)) {
                for (const row of rows) {
                  if (candidates[row][col].includes(num)) {
                    eliminations.push({row, col});
                  }
                }
              }
            }
            
            if (eliminations.length > 0) {
              const positions = [];
              for (const row of rows) {
                for (const col of cols) {
                  if (candidates[row][col].includes(num)) {
                    positions.push({row, col});
                  }
                }
              }
              
              return {
                type: "swordfish",
                positions,
                value: num,
                eliminations,
                explanation: `<div class="hint-section">
                  <span class="technique-name">Swordfish</span> for number ${num}<br><br>
                  In Columns ${cols.map(c => c + 1).join(", ")}, the number <strong>${num}</strong> is confined to Rows ${rows.map(r => r + 1).join(", ")}.<br><br>
                  <strong>What this means:</strong><br>
                  This forms a Swordfish pattern - ${num} must appear exactly once in each of these 3 columns,<br>
                  and all possible positions are within these 3 rows.<br><br>
                  Therefore, ${num} can be <em>eliminated</em> from all other cells in Rows ${rows.map(r => r + 1).join(", ")}.<br><br>
                  <strong>Eliminations:</strong><br>
                  ${eliminations.map(e => `- Remove ${num} from Row ${e.row + 1}, Column ${e.col + 1}`).join("<br>")}
                </div>`
              };
            }
          }
        }
      }
    }
  }
  return null;
}

function getNextHint() {
  const grid = getGrid();
  const messageDiv = document.getElementById("message");
  clearHighlights();

  const emptyCells = grid.flat().filter(c => c === 0).length;
  if (emptyCells === 0) {
    messageDiv.innerHTML = "The puzzle is complete! Use 'Check Rules' to verify your solution.";
    currentHint = null;
    return;
  }

  const basicCandidates = getAllCandidates(grid);
  const refinedCandidates = applyEliminationTechniques(basicCandidates);

  let hint = findNakedSingle(grid, refinedCandidates);
  if (!hint) hint = findHiddenSingle(grid, refinedCandidates);
  
  if (!hint) {
    hint = findPointingPair(grid, basicCandidates);
    if (!hint) hint = findBoxLineReduction(grid, basicCandidates);
    if (!hint) hint = findNakedPair(grid, basicCandidates);
    if (!hint) hint = findXWing(grid, basicCandidates);
    if (!hint) hint = findSwordfish(grid, basicCandidates);
  }

  if (hint) {
    currentHint = hint;
    showMessage(hint.explanation);
    
    if (hint.type === "naked_single" || hint.type === "hidden_single") {
      highlightCell(hint.row, hint.col, "hint");
    } else if (hint.cells) {
      hint.cells.forEach(c => highlightCell(c.row, c.col, "hint"));
    } else if (hint.positions) {
      hint.positions.forEach(p => highlightCell(p.row, p.col, "hint"));
    }
    
    if (hint.eliminations) {
      hint.eliminations.forEach(e => highlightCell(e.row, e.col, "related"));
    }
  } else {
    currentHint = null;
    const hasEmptyCells = refinedCandidates.some(row => row.some(c => c.length > 0));
    if (hasEmptyCells) {
      showMessage(`No technique found. Try these approaches:<br><br>
        1. Look for cells with only 2-3 candidates and think about what would happen if you placed each one.<br>
        2. Check if any row/column/box is almost complete.<br>
        3. The puzzle may require techniques beyond what's implemented here.<br><br>
        Click "Show Candidates" to see all possibilities for each cell.`);
    } else {
      showMessage("No valid candidates found. The puzzle may have an error. Use 'Check Rules' to verify.", "error");
    }
  }
}

function applyHint() {
  if (!currentHint) {
    showMessage("No hint to apply. Click 'Get Next Hint' first.");
    return;
  }

  if (currentHint.type === "naked_single" || currentHint.type === "hidden_single") {
    const input = document.querySelector(`input[data-row="${currentHint.row}"][data-col="${currentHint.col}"]`);
    if (input) {
      input.value = currentHint.value;
      input.classList.add("solved");
    }
    showMessage(`Applied: ${currentHint.value} at Row ${currentHint.row + 1}, Column ${currentHint.col + 1}.<br><br>Click 'Get Next Hint' for the next step.`);
  } else {
    showMessage("This hint shows eliminations (removing candidates), not a direct placement.<br><br>Use the insight to continue solving manually, then click 'Get Next Hint'.");
  }
  
  currentHint = null;
  clearHighlights();
  if (showingCandidates) showAllCandidates();
}

function highlightCell(row, col, type) {
  const input = document.querySelector(`input[data-row="${row}"][data-col="${col}"]`);
  if (input) {
    input.classList.remove("hint", "related", "incorrect");
    input.classList.add(type);
  }
}

function clearHighlights() {
  document.querySelectorAll("#sudokuGrid input").forEach(input => {
    input.classList.remove("hint", "related", "incorrect");
  });
}

function applyEliminationTechniques(candidates) {
  const refined = candidates.map(row => row.map(c => [...c]));
  let changed = true;
  let iterations = 0;
  const maxIterations = 10;
  
  while (changed && iterations < maxIterations) {
    changed = false;
    iterations++;
    
    for (let boxRow = 0; boxRow < 3; boxRow++) {
      for (let boxCol = 0; boxCol < 3; boxCol++) {
        for (let num = 1; num <= 9; num++) {
          const positions = [];
          for (let i = 0; i < 3; i++) {
            for (let j = 0; j < 3; j++) {
              const r = boxRow * 3 + i;
              const c = boxCol * 3 + j;
              if (refined[r][c].includes(num)) {
                positions.push({row: r, col: c});
              }
            }
          }
          
          if (positions.length >= 2 && positions.length <= 3) {
            const allSameRow = positions.every(p => p.row === positions[0].row);
            const allSameCol = positions.every(p => p.col === positions[0].col);
            
            if (allSameRow) {
              const row = positions[0].row;
              for (let col = 0; col < 9; col++) {
                const inBox = col >= boxCol * 3 && col < boxCol * 3 + 3;
                if (!inBox && refined[row][col].includes(num)) {
                  refined[row][col] = refined[row][col].filter(n => n !== num);
                  changed = true;
                }
              }
            }
            
            if (allSameCol) {
              const col = positions[0].col;
              for (let row = 0; row < 9; row++) {
                const inBox = row >= boxRow * 3 && row < boxRow * 3 + 3;
                if (!inBox && refined[row][col].includes(num)) {
                  refined[row][col] = refined[row][col].filter(n => n !== num);
                  changed = true;
                }
              }
            }
          }
        }
      }
    }
    
    for (let row = 0; row < 9; row++) {
      for (let num = 1; num <= 9; num++) {
        const positions = [];
        for (let col = 0; col < 9; col++) {
          if (refined[row][col].includes(num)) {
            positions.push({row, col});
          }
        }
        if (positions.length >= 2 && positions.length <= 3) {
          const boxCol = Math.floor(positions[0].col / 3);
          const allSameBox = positions.every(p => Math.floor(p.col / 3) === boxCol);
          if (allSameBox) {
            const boxRow = Math.floor(row / 3);
            for (let i = 0; i < 3; i++) {
              for (let j = 0; j < 3; j++) {
                const r = boxRow * 3 + i;
                const c = boxCol * 3 + j;
                if (r !== row && refined[r][c].includes(num)) {
                  refined[r][c] = refined[r][c].filter(n => n !== num);
                  changed = true;
                }
              }
            }
          }
        }
      }
    }
    
    for (let col = 0; col < 9; col++) {
      for (let num = 1; num <= 9; num++) {
        const positions = [];
        for (let row = 0; row < 9; row++) {
          if (refined[row][col].includes(num)) {
            positions.push({row, col});
          }
        }
        if (positions.length >= 2 && positions.length <= 3) {
          const boxRow = Math.floor(positions[0].row / 3);
          const allSameBox = positions.every(p => Math.floor(p.row / 3) === boxRow);
          if (allSameBox) {
            const boxCol = Math.floor(col / 3);
            for (let i = 0; i < 3; i++) {
              for (let j = 0; j < 3; j++) {
                const r = boxRow * 3 + i;
                const c = boxCol * 3 + j;
                if (c !== col && refined[r][c].includes(num)) {
                  refined[r][c] = refined[r][c].filter(n => n !== num);
                  changed = true;
                }
              }
            }
          }
        }
      }
    }
    
    for (let row = 0; row < 9; row++) {
      const pairs = [];
      for (let col = 0; col < 9; col++) {
        if (refined[row][col].length === 2) {
          pairs.push({col, cands: refined[row][col]});
        }
      }
      for (let i = 0; i < pairs.length; i++) {
        for (let j = i + 1; j < pairs.length; j++) {
          if (pairs[i].cands[0] === pairs[j].cands[0] && pairs[i].cands[1] === pairs[j].cands[1]) {
            const [n1, n2] = pairs[i].cands;
            for (let col = 0; col < 9; col++) {
              if (col !== pairs[i].col && col !== pairs[j].col) {
                if (refined[row][col].includes(n1) || refined[row][col].includes(n2)) {
                  refined[row][col] = refined[row][col].filter(n => n !== n1 && n !== n2);
                  changed = true;
                }
              }
            }
          }
        }
      }
    }
    
    for (let col = 0; col < 9; col++) {
      const pairs = [];
      for (let row = 0; row < 9; row++) {
        if (refined[row][col].length === 2) {
          pairs.push({row, cands: refined[row][col]});
        }
      }
      for (let i = 0; i < pairs.length; i++) {
        for (let j = i + 1; j < pairs.length; j++) {
          if (pairs[i].cands[0] === pairs[j].cands[0] && pairs[i].cands[1] === pairs[j].cands[1]) {
            const [n1, n2] = pairs[i].cands;
            for (let row = 0; row < 9; row++) {
              if (row !== pairs[i].row && row !== pairs[j].row) {
                if (refined[row][col].includes(n1) || refined[row][col].includes(n2)) {
                  refined[row][col] = refined[row][col].filter(n => n !== n1 && n !== n2);
                  changed = true;
                }
              }
            }
          }
        }
      }
    }
    
    for (let num = 1; num <= 9; num++) {
      const rowPositions = [];
      for (let row = 0; row < 9; row++) {
        const cols = [];
        for (let col = 0; col < 9; col++) {
          if (refined[row][col].includes(num)) cols.push(col);
        }
        if (cols.length === 2) {
          rowPositions.push({row, cols});
        }
      }
      
      for (let i = 0; i < rowPositions.length; i++) {
        for (let j = i + 1; j < rowPositions.length; j++) {
          if (rowPositions[i].cols[0] === rowPositions[j].cols[0] && 
              rowPositions[i].cols[1] === rowPositions[j].cols[1]) {
            const row1 = rowPositions[i].row;
            const row2 = rowPositions[j].row;
            const col1 = rowPositions[i].cols[0];
            const col2 = rowPositions[i].cols[1];
            
            for (let row = 0; row < 9; row++) {
              if (row !== row1 && row !== row2) {
                if (refined[row][col1].includes(num)) {
                  refined[row][col1] = refined[row][col1].filter(n => n !== num);
                  changed = true;
                }
                if (refined[row][col2].includes(num)) {
                  refined[row][col2] = refined[row][col2].filter(n => n !== num);
                  changed = true;
                }
              }
            }
          }
        }
      }
      
      const colPositions = [];
      for (let col = 0; col < 9; col++) {
        const rows = [];
        for (let row = 0; row < 9; row++) {
          if (refined[row][col].includes(num)) rows.push(row);
        }
        if (rows.length === 2) {
          colPositions.push({col, rows});
        }
      }
      
      for (let i = 0; i < colPositions.length; i++) {
        for (let j = i + 1; j < colPositions.length; j++) {
          if (colPositions[i].rows[0] === colPositions[j].rows[0] && 
              colPositions[i].rows[1] === colPositions[j].rows[1]) {
            const col1 = colPositions[i].col;
            const col2 = colPositions[j].col;
            const row1 = colPositions[i].rows[0];
            const row2 = colPositions[i].rows[1];
            
            for (let col = 0; col < 9; col++) {
              if (col !== col1 && col !== col2) {
                if (refined[row1][col].includes(num)) {
                  refined[row1][col] = refined[row1][col].filter(n => n !== num);
                  changed = true;
                }
                if (refined[row2][col].includes(num)) {
                  refined[row2][col] = refined[row2][col].filter(n => n !== num);
                  changed = true;
                }
              }
            }
          }
        }
      }
    }
  }
  
  return refined;
}

function showAllCandidates() {
  const grid = getGrid();
  const basicCandidates = getAllCandidates(grid);
  const candidates = applyEliminationTechniques(basicCandidates);
  showingCandidates = true;

  document.querySelectorAll(".candidates").forEach(el => el.remove());

  for (let row = 0; row < 9; row++) {
    for (let col = 0; col < 9; col++) {
      if (grid[row][col] === 0 && candidates[row][col].length > 0) {
        const cell = document.querySelector(`input[data-row="${row}"][data-col="${col}"]`).parentElement;
        const candDiv = document.createElement("div");
        candDiv.className = "candidates";
        for (let n = 1; n <= 9; n++) {
          const span = document.createElement("span");
          span.textContent = candidates[row][col].includes(n) ? n : "";
          candDiv.appendChild(span);
        }
        cell.appendChild(candDiv);
      }
    }
  }
}

function checkRules() {
  const grid = getGrid();
  const messageDiv = document.getElementById("message");
  const errors = [];
  
  clearHighlights();
  document.querySelectorAll("#sudokuGrid input").forEach(input => {
    input.classList.remove("incorrect");
  });

  for (let row = 0; row < 9; row++) {
    const seen = new Map();
    for (let col = 0; col < 9; col++) {
      const val = grid[row][col];
      if (val > 0) {
        if (seen.has(val)) {
          errors.push(`Duplicate ${val} in Row ${row + 1}`);
          highlightCell(row, col, "incorrect");
          highlightCell(row, seen.get(val), "incorrect");
        }
        seen.set(val, col);
      }
    }
  }

  for (let col = 0; col < 9; col++) {
    const seen = new Map();
    for (let row = 0; row < 9; row++) {
      const val = grid[row][col];
      if (val > 0) {
        if (seen.has(val)) {
          errors.push(`Duplicate ${val} in Column ${col + 1}`);
          highlightCell(row, col, "incorrect");
          highlightCell(seen.get(val), col, "incorrect");
        }
        seen.set(val, row);
      }
    }
  }

  for (let boxRow = 0; boxRow < 3; boxRow++) {
    for (let boxCol = 0; boxCol < 3; boxCol++) {
      const seen = new Map();
      for (let i = 0; i < 3; i++) {
        for (let j = 0; j < 3; j++) {
          const r = boxRow * 3 + i;
          const c = boxCol * 3 + j;
          const val = grid[r][c];
          if (val > 0) {
            if (seen.has(val)) {
              errors.push(`Duplicate ${val} in ${getBoxName(r, c)} box`);
              highlightCell(r, c, "incorrect");
              const prev = seen.get(val);
              highlightCell(prev.row, prev.col, "incorrect");
            }
            seen.set(val, {row: r, col: c});
          }
        }
      }
    }
  }

  const emptyCells = grid.flat().filter(c => c === 0).length;

  if (errors.length > 0) {
    const uniqueErrors = [...new Set(errors)];
    showMessage(`<strong>Rule violations found:</strong><br>${uniqueErrors.map(e => `- ${e}`).join("<br>")}`, "error");
  } else if (emptyCells === 0) {
    showMessage("<strong>No rule violations!</strong> The puzzle follows all Sudoku rules.", "success");
  } else {
    showMessage(`<strong>No rule violations.</strong> ${emptyCells} cells remaining.`);
  }
}

function solvePuzzle(grid, findAllSolutions = false, maxSolutions = 2) {
  const copy = grid.map(row => row.slice());
  const solutions = [];
  solverStartTime = Date.now();
  
  function findEmpty() {
    let bestCell = null;
    let minCandidates = 10;
    
    // MRV heuristic: find empty cell with fewest candidates
    for (let i = 0; i < 9; i++) {
      for (let j = 0; j < 9; j++) {
        if (copy[i][j] === 0) {
          const candidates = getCandidates(copy, i, j);
          if (candidates.length === 0) return null; // dead end
          if (candidates.length < minCandidates) {
            minCandidates = candidates.length;
            bestCell = [i, j];
            if (minCandidates === 1) break; // can't get better than 1
          }
        }
      }
    }
    return bestCell;
  }
  
  function isValid(row, col, num) {
    for (let x = 0; x < 9; x++) if (copy[row][x] === num) return false;
    for (let x = 0; x < 9; x++) if (copy[x][col] === num) return false;
    const boxRow = Math.floor(row / 3) * 3;
    const boxCol = Math.floor(col / 3) * 3;
    for (let i = 0; i < 3; i++)
      for (let j = 0; j < 3; j++)
        if (copy[boxRow + i][boxCol + j] === num) return false;
    return true;
  }
  
  function solve() {
    // Check timeout
    if (Date.now() - solverStartTime > SOLVER_TIMEOUT) {
      throw new Error("Solver timeout");
    }
    
    const empty = findEmpty();
    if (!empty) {
      if (findAllSolutions) {
        solutions.push(copy.map(row => row.slice()));
        return solutions.length < maxSolutions;
      }
      return true;
    }
    
    const [row, col] = empty;
    const candidates = getCandidates(copy, row, col);
    
    for (const num of candidates) {
      copy[row][col] = num;
      if (solve()) {
        if (!findAllSolutions) return true;
      }
      copy[row][col] = 0;
    }
    return false;
  }
  
  try {
    if (findAllSolutions) {
      solve();
      return solutions.length > 0 ? solutions : null;
    } else {
      return solve() ? copy : null;
    }
  } catch (e) {
    if (e.message === "Solver timeout") {
      return null; // timeout indicates too complex
    }
    throw e;
  }
}

function checkSolution() {
  const grid = getGrid();
  const messageDiv = document.getElementById("message");
  
  clearHighlights();
  document.querySelectorAll("#sudokuGrid input").forEach(input => {
    input.classList.remove("incorrect");
  });

  if (!originalPuzzle) {
    showMessage(`<strong>No puzzle locked!</strong><br><br>
      To check your solution, first enter the original puzzle clues, then click "Lock Puzzle".<br>
      This tells the system which numbers are the original clues vs your answers.`);
    return;
  }

  const solutions = solvePuzzle(originalPuzzle, true, 3);
  
  if (!solutions) {
    showMessage("<strong>No valid solution exists!</strong> The locked puzzle has contradictions.", "error");
    return;
  }

  const incorrectCells = [];
  const hasMultipleSolutions = solutions.length > 1;
  
  for (let row = 0; row < 9; row++) {
    for (let col = 0; col < 9; col++) {
      if (grid[row][col] > 0) {
        const userValue = grid[row][col];
        const isValidValue = solutions.some(sol => sol[row][col] === userValue);
        
        if (!isValidValue) {
          incorrectCells.push({row, col, entered: userValue});
          highlightCell(row, col, "incorrect");
        }
      }
    }
  }

  const emptyCells = grid.flat().filter(c => c === 0).length;

  if (incorrectCells.length > 0) {
    showMessage(`<strong>${incorrectCells.length} incorrect number(s) found:</strong><br>
      ${incorrectCells.map(c => `- Row ${c.row + 1}, Column ${c.col + 1}: You entered ${c.entered}`).join("<br>")}<br><br>
      <em>Incorrect cells are highlighted in red.</em>`, "error");
  } else if (emptyCells === 0) {
    let msg = "<strong>Congratulations!</strong> All numbers are correct! Puzzle solved!";
    if (hasMultipleSolutions) {
      msg += "<br><br><em>Note: This puzzle has multiple valid solutions.</em>";
    }
    showMessage(msg, "success");
  } else {
    let msg = `<strong>All entered numbers are correct!</strong> ${emptyCells} cells remaining.`;
    if (hasMultipleSolutions) {
      msg += "<br><br><em>Note: This puzzle has multiple possible solutions.</em>";
    }
    showMessage(msg);
  }
}

function validateAndLockGrid(grid, isImport = false) {
  const filledCells = grid.flat().filter(c => c > 0).length;
  
  if (filledCells < 17) {
    showMessage("Need at least 17 clues to lock a valid puzzle.", "error");
    return false;
  }
  
  // Test if puzzle is solvable with timeout
  const solution = solvePuzzle(grid);
  if (!solution) {
    showMessage("<strong>Invalid puzzle!</strong> This puzzle has no valid solution. Check for errors.", "error");
    return false;
  }
  
  originalPuzzle = grid.map(row => row.slice());
  
  // Clear all states first
  clearHighlights();
  document.querySelectorAll("#sudokuGrid input").forEach(input => {
    input.classList.remove("solved", "hint", "related", "incorrect", "locked");
    input.readOnly = false;
  });
  
  // Apply locked state to original clues
  document.querySelectorAll("#sudokuGrid input").forEach(input => {
    const r = parseInt(input.dataset.row);
    const c = parseInt(input.dataset.col);
    if (originalPuzzle[r][c] > 0) {
      input.classList.add("locked");
      input.readOnly = true;
    }
  });
  
  const action = isImport ? "imported and locked" : "locked";
  showMessage(`<strong>Puzzle ${action}!</strong> ${filledCells} clues saved.<br><br>
    Original clues are now shown in bold and cannot be edited.<br>
    You can now solve the puzzle and use "Check Solution" to verify your answers.`);
  
  return true;
}

function lockPuzzle() {
  const grid = getGrid();
  validateAndLockGrid(grid, false);
}

function clearGrid() {
  document.querySelectorAll("#sudokuGrid input").forEach(input => {
    input.value = "";
    input.classList.remove("solved", "hint", "related", "incorrect", "locked");
    input.readOnly = false;
  });
  document.querySelectorAll(".candidates").forEach(el => el.remove());
  showingCandidates = false;
  currentHint = null;
  originalPuzzle = null;
  
  // Update URL to remove puzzle
  const url = new URL(window.location);
  url.searchParams.delete('puzzle');
  window.history.replaceState({}, '', url);
  
  showMessage("Grid cleared. Enter a new puzzle.");
}

function exportGrid() {
  const grid = getGrid();
  let text = "";
  for (let row of grid) {
    text += row.map(cell => cell || ".").join("") + "\n";
  }
  
  const timestamp = new Date().toISOString().slice(0, 10);
  const blob = new Blob([text], {type: "text/plain"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = `sudoku-${timestamp}.txt`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
  showMessage(`Grid exported as sudoku-${timestamp}.txt`);
}

// Safe message display function
function showMessage(content, type = "info") {
  const messageDiv = document.getElementById("message");
  
  // Clear existing content safely
  while (messageDiv.firstChild) {
    messageDiv.removeChild(messageDiv.firstChild);
  }
  
  // Create safe content
  if (type === "error") {
    messageDiv.style.background = "#ffebee";
    messageDiv.style.border = "1px solid #f44336";
  } else if (type === "success") {
    messageDiv.style.background = "#e8f5e8";
    messageDiv.style.border = "1px solid #4caf50";
  } else {
    messageDiv.style.background = "#f5f5f5";
    messageDiv.style.border = "1px solid #ddd";
  }
  
  // Parse and create safe HTML elements
  const tempDiv = document.createElement('div');
  tempDiv.innerHTML = content;
  
  // Only allow safe elements and attributes
  const allowedTags = ['div', 'strong', 'br', 'em', 'span'];
  const allowedAttributes = ['class'];
  
  function sanitizeNode(node) {
    if (node.nodeType === Node.TEXT_NODE) {
      return node.cloneNode(true);
    }
    
    if (node.nodeType === Node.ELEMENT_NODE) {
      const tagName = node.tagName.toLowerCase();
      if (!allowedTags.includes(tagName)) {
        return document.createTextNode('');
      }
      
      const newNode = document.createElement(tagName);
      
      // Copy only allowed attributes
      for (const attr of node.attributes) {
        if (allowedAttributes.includes(attr.name)) {
          newNode.setAttribute(attr.name, attr.value);
        }
      }
      
      // Recursively process children
      for (const child of node.childNodes) {
        const sanitizedChild = sanitizeNode(child);
        if (sanitizedChild) {
          newNode.appendChild(sanitizedChild);
        }
      }
      
      return newNode;
    }
    
    return null;
  }
  
  // Sanitize and append content
  for (const child of tempDiv.childNodes) {
    const sanitizedChild = sanitizeNode(child);
    if (sanitizedChild) {
      messageDiv.appendChild(sanitizedChild);
    }
  }
}

// URL state persistence functions
function gridToString(grid) {
  return grid.map(row => row.map(cell => cell || '.').join('')).join('');
}

function stringToGrid(str) {
  const grid = [];
  if (str.length !== 81) return null;
  
  for (let i = 0; i < 9; i++) {
    const row = [];
    for (let j = 0; j < 9; j++) {
      const char = str[i * 9 + j];
      row.push("123456789".includes(char) ? parseInt(char) : 0);
    }
    grid.push(row);
  }
  return grid;
}

function shareViaURL() {
  const grid = getGrid();
  const puzzleString = gridToString(grid);
  
  try {
    const compressed = btoa(puzzleString).replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
    const url = new URL(window.location);
    url.searchParams.set('puzzle', compressed);
    
    if (navigator.clipboard) {
      navigator.clipboard.writeText(url.toString()).then(() => {
        showMessage("Puzzle URL copied to clipboard!<br><br>Share this link with others to play the same puzzle.");
      }).catch(() => {
        showMessage("Puzzle URL created:<br><br>" + url.toString());
      });
    } else {
      showMessage("Puzzle URL created:<br><br>" + url.toString());
    }
  } catch (error) {
    showMessage("Error creating shareable URL.", "error");
  }
}

function loadFromURL() {
  const url = new URL(window.location);
  const compressed = url.searchParams.get('puzzle');
  
  if (compressed) {
    try {
      // Reverse the base64 encoding
      const puzzleString = atob(compressed.replace(/-/g, '+').replace(/_/g, '/'));
      const grid = stringToGrid(puzzleString);
      
      if (grid) {
        setGrid(grid);
        if (validateAndLockGrid(grid, true)) {
          showMessage("Puzzle loaded from URL!<br><br>You can now solve the puzzle.");
        }
      } else {
        showMessage("Invalid puzzle format in URL.", "error");
      }
    } catch (error) {
      showMessage("Error loading puzzle from URL.", "error");
    }
  } else {
    showMessage("No puzzle found in URL.<br><br>Share a puzzle first, then copy the URL.");
  }
}

const importFile = document.getElementById("importFile");
importFile.addEventListener("change", (e) => {
  if (!e.target.files.length) return;
  const file = e.target.files[0];
  
  // Validate file size (100KB limit for text files)
  const MAX_SIZE = 100 * 1024;
  if (file.size > MAX_SIZE) {
    showMessage("File too large. Maximum size is 100KB.", "error");
    e.target.value = "";
    return;
  }
  
  const reader = new FileReader();
  reader.onload = (ev) => {
    try {
      const text = ev.target.result;
      const lines = text.trim().split(/\r?\n/).filter(line => line.trim() && !line.startsWith("#"));
      
      let grid = null;
      
      if (lines.length === 1 && lines[0].length === 81) {
        grid = [];
        for (let i = 0; i < 9; i++) {
          const row = [];
          for (let j = 0; j < 9; j++) {
            const char = lines[0][i * 9 + j];
            row.push("123456789".includes(char) ? parseInt(char) : 0);
          }
          grid.push(row);
        }
      } else if (lines.length >= 9) {
        grid = [];
        for (let i = 0; i < 9; i++) {
          const line = lines[i].replace(/[^0-9.]/g, "");
          if (line.length < 9) {
            showMessage(`Invalid file: Line ${i + 1} has fewer than 9 digits.`, "error");
            e.target.value = "";
            return;
          }
          const row = [];
          for (let j = 0; j < 9; j++) {
            const char = line[j];
            row.push("123456789".includes(char) ? parseInt(char) : 0);
          }
          grid.push(row);
        }
      } else {
        showMessage("Invalid file format. Expected 9 lines or 81 characters.", "error");
        e.target.value = "";
        return;
      }
      
      if (grid) {
        setGrid(grid);
        
        // Use validation function instead of direct assignment
        if (validateAndLockGrid(grid, true)) {
          showingCandidates = false;
          document.querySelectorAll(".candidates").forEach(el => el.remove());
        }
      }
    } catch (error) {
      showMessage("Error reading file. Please check the format.", "error");
    }
    
    e.target.value = "";
  };
  reader.readAsText(file);
});

// Load puzzle from URL on page load if present
document.addEventListener('DOMContentLoaded', function() {
  const url = new URL(window.location);
  const compressed = url.searchParams.get('puzzle');
  
  if (compressed) {
    try {
      const puzzleString = atob(compressed.replace(/-/g, '+').replace(/_/g, '/'));
      const grid = stringToGrid(puzzleString);
      
      if (grid) {
        setGrid(grid);
        setTimeout(() => {
          if (validateAndLockGrid(grid, true)) {
            showMessage("Puzzle loaded from URL!<br><br>You can now solve the puzzle.");
          }
        }, 500);
      }
    } catch (error) {
      // Invalid URL parameter, ignore
    }
  }
});

</script>

</body>
</html>